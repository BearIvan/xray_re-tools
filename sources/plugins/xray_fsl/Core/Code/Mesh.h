#pragma once

#include "Types.h"
#include "xr_fixed_vector.h"
#include "Vector3.h"
#include "Vector2.h"
#include "AABB.h"

namespace xrFSL
{
	// forward decl
	class Reader;
	class Writer;
	class Object;
	class Surface;

	// editable mesh flags
	enum 
	{
		EMF_VALID	= 0x01,	// no rendering and collision (wireframe works though)
		EMF_3DSMAX	= 0x04,	// generated by 3ds Max export plugin (different sgroups)
	};

	const uint32 EMESH_NO_SG = 0xffffffff;

	class VMap 
	{
	public:
		VMap(): m_bPolymap(false) {};
		VMap(const char* pszName): m_sName(pszName), m_bPolymap(false) {};
		VMap(const String& sName): m_sName(sName), m_bPolymap(false) {};
		virtual	~VMap() {};

		virtual void Load(Reader& r) = 0;
		virtual void Save(Writer& w) const = 0;

		virtual void Reserve(size_t _Size) { m_vecVertices.reserve(_Size); };
		uint32 AddVertex(uint32 vert_idx);

		static VMap* Create(const char* pszName, unsigned uType, unsigned uDimension, bool bDiscontiguous);

		struct SRead0 { void operator()(VMap*& vmap, Reader& r); };
		struct SRead1 { void operator()(VMap*& vmap, Reader& r); };
		struct SRead2 { void operator()(VMap*& vmap, Reader& r); };
		
		struct SWrite 
		{ 
			void operator()(const VMap* vmap, Writer& w) const; 
		};

		enum 
		{
			VMT_UV,
			VMT_WEIGHT,
		};

		virtual unsigned type() const = 0;
		size_t size() const;
		const String& name() const;
		const std::vector<uint32>& vertices() const;
		bool IsPolymap(void) const; 
	protected:
		String m_sName;
		std::vector<uint32>	m_vecVertices;
		bool m_bPolymap;
	};

	class xrFSL_CORE_API UVVMap: public VMap 
	{
	public:
		UVVMap(const char* pszName): VMap(pszName) {};
		UVVMap(const String& sName): VMap(sName) {};

		virtual void Load(Reader& r);
		virtual void Save(Writer& w) const;

		virtual void Reserve(size_t uSize) { VMap::Reserve(uSize); m_vecUVs.reserve(uSize); };
		uint32 AddUV(const fVector2& fv2UV, uint32 uiVertIdx);

		virtual unsigned type() const { return VMT_UV; };
		const std::vector<fVector2>& UVs() const;
	protected:
		std::vector<fVector2> m_vecUVs;
	};

	TYPEDEF_STD_VECTOR_PTR(VMap)

	class xrFSL_CORE_API FaceUVVmap: public UVVMap 
	{
	public:
		FaceUVVmap(const char* pszName): UVVMap(pszName) { m_bPolymap = true; };
		FaceUVVmap(const String& sName): UVVMap(sName) { m_bPolymap = true; };

		virtual void Load(Reader& r);
		virtual void Save(Writer& w) const;

		virtual void Reserve(size_t uSize) { UVVMap::Reserve(uSize); m_vecFaces.reserve(uSize); };
		uint32 AddUV(const fVector2& fv2UV, uint32 uiVertIdx, uint32 uiFaceIdx);

		const std::vector<uint32>& faces() const;
	protected:
		std::vector<uint32>	m_vecFaces;
	};

	class WeightVMap: public VMap 
	{
	public:
		WeightVMap(const char* pszName): VMap(pszName) {};
		WeightVMap(const String& sName): VMap(sName) {};

		virtual void Load(Reader& r);
		virtual void Save(Writer& w) const;

		virtual void Reserve(size_t uSize) { VMap::Reserve(uSize); m_vecWeights.reserve(uSize); };
		uint32 AddWeight(float fWeight, uint32 uiVertIdx);

		virtual unsigned type() const { return VMT_WEIGHT; };
		const std::vector<float>& weights() const;
	protected:
		std::vector<float>	m_vecWeights;
	};

	TYPEDEF_STD_VECTOR_PTR(WeightVMap)

	struct SurfaceMap 
	{
		SurfaceMap();
		SurfaceMap(Surface* pSurface);
		Surface* pSurface;
		std::vector<uint32>	vecFaces;
	};

	TYPEDEF_STD_VECTOR_PTR(SurfaceMap)


	struct LWOptions 
	{
		uint32 unk1;
		uint32 unk2;
	};

	struct LWFace
	{
		LWFace();
		LWFace(uint32 uiV0, uint32 uiV1, uint32 uiV2);
		union 
		{
			struct 
			{
				uint32 v[3];
				uint32 ref[3];
			};
			struct 
			{
				uint32 v0, v1, v2;
				uint32 ref0, ref1, ref2;
			};
		};
	};

	TYPEDEF_STD_VECTOR(LWFace)

	
	struct lw_vmref_entry 
	{
		lw_vmref_entry();
		lw_vmref_entry(uint32 _vmap, uint32 _offset);
		bool operator==(const lw_vmref_entry& right) const;
		bool operator<(const lw_vmref_entry& right) const;

		uint32 vmap;		///< индекс VMap
		uint32 offset;		///< индекс в VMap на uv/w
	};

	typedef xray_re::_svector<lw_vmref_entry, 5> lw_vmref;

	TYPEDEF_STD_VECTOR(lw_vmref)


	class xrFSL_CORE_API Mesh
	{
	public:
		Mesh();
		virtual ~Mesh();

		void Load(Reader& r, Object& object);
		void Save(Writer& w) const;

		String& name();
		const String& name() const;
		uint8 flags() const;
		uint8& flags();
		fBox& bbox();
		const fBox& bbox() const;
		std::vector<fVector3>& points();
		const std::vector<fVector3>& points() const;
		LWFace_vec& faces();
		const LWFace_vec& faces() const;
		std::vector<uint32>& sgroups();
		const std::vector<uint32>& sgroups() const;
		lw_vmref_vec& vmrefs();
		const lw_vmref_vec& vmrefs() const;
		SurfaceMap_vec& surfmaps();
		const SurfaceMap_vec& surfmaps() const;
		VMap_vec& vmaps();
		const VMap_vec& vmaps() const;

		void CalculateBBox();
	protected:
		String m_sName;						// EMESH_CHUNK_MESHName
		uint8 m_uiFlags;					// EMESH_CHUNK_FLAGS
		LWOptions m_SOptions;				// EMESH_CHUNK_OPTIONS
		fBox m_bbox;						// EMESH_CHUNK_BBOX
		std::vector<fVector3> m_vecPoints;	// EMESH_CHUNK_VERTS
		std::vector<uint8> m_vecAdjCounts;
		std::vector<uint32> m_vecAdjRefs;
		LWFace_vec m_vecFaces;				// EMESH_CHUNK_FACES
		std::vector<uint32> m_vecSGroups;	// EMESH_CHUNK_SG
		lw_vmref_vec m_vmrefs;				// EMESH_CHUNK_VMREFS
		SurfaceMap_vec m_vecSurfaceMaps;	// EMESH_CHUNK_SFACE
		VMap_vec m_vecVMaps;				// EMESH_CHUNK_VMAPS
	};

	TYPEDEF_STD_VECTOR_PTR(Mesh)

	//==========================================
	// Inline impl
	//==========================================
	inline size_t VMap::size() const { return m_vecVertices.size(); }
	inline bool VMap::IsPolymap() const { return m_bPolymap; }
	inline const std::string& VMap::name() const { return m_sName; }
	inline const std::vector<uint32>& VMap::vertices() const { return m_vecVertices; }
	inline const std::vector<fVector2>& UVVMap::UVs() const { return m_vecUVs; }
	inline const std::vector<uint32>& FaceUVVmap::faces() const { return m_vecFaces; }
	inline const std::vector<float>& WeightVMap::weights() const { return m_vecWeights; }

	inline LWFace::LWFace() {}
	inline LWFace::LWFace(uint32 _v0, uint32 _v1, uint32 _v2):
	v0(_v0), v1(_v1), v2(_v2), ref0(UINT32_MAX), ref1(UINT32_MAX), ref2(UINT32_MAX) {}

	inline lw_vmref_entry::lw_vmref_entry() {}
	inline lw_vmref_entry::lw_vmref_entry(uint32 _vmap, uint32 _offset):
	vmap(_vmap), offset(_offset) {}

	inline bool lw_vmref_entry::operator==(const lw_vmref_entry& right) const
	{
		return vmap == right.vmap && offset == right.offset;
	}

	inline bool lw_vmref_entry::operator<(const lw_vmref_entry& right) const
	{
		return vmap < right.vmap || (vmap == right.vmap && offset < right.offset);
	}

	inline SurfaceMap::SurfaceMap(): pSurface(0) {}
	inline SurfaceMap::SurfaceMap(Surface* _surface): pSurface(_surface) {}

	inline std::string& Mesh::name() { return m_sName; }
	inline const std::string& Mesh::name() const { return m_sName; }
	inline uint8& Mesh::flags() { return m_uiFlags; }
	inline uint8 Mesh::flags() const { return m_uiFlags; }
	inline fBox& Mesh::bbox() { return m_bbox; }
	inline const fBox& Mesh::bbox() const { return m_bbox; }
	inline std::vector<fVector3>& Mesh::points() { return m_vecPoints; }
	inline const std::vector<fVector3>& Mesh::points() const { return m_vecPoints; }
	inline LWFace_vec& Mesh::faces() { return m_vecFaces; }
	inline const LWFace_vec& Mesh::faces() const { return m_vecFaces; }
	inline std::vector<uint32>& Mesh::sgroups() { return m_vecSGroups; }
	inline const std::vector<uint32>& Mesh::sgroups() const { return m_vecSGroups; }
	inline lw_vmref_vec& Mesh::vmrefs() { return m_vmrefs; }
	inline const lw_vmref_vec& Mesh::vmrefs() const { return m_vmrefs; }
	inline SurfaceMap_vec& Mesh::surfmaps() { return m_vecSurfaceMaps; }
	inline const SurfaceMap_vec& Mesh::surfmaps() const { return m_vecSurfaceMaps; }
	inline VMap_vec& Mesh::vmaps() { return m_vecVMaps; }
	inline const VMap_vec& Mesh::vmaps() const { return m_vecVMaps; }
}
