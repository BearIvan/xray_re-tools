Интересная информация от bardak'а по поводу движка, компиляции карт, их конверта ТЧ в ЧН и наоборот.


[Вопрос]

Геометрия в сталкере, связано ли "fuflo" с лодами?

[Ответ]

В сталкере (игре, а не редакторе) есть два набора геометрии -- visuals и cform. В первый набор входит
вся видимая статическая геометрия, включая MU-модели. Во второй -- невидимая геометрия для обсчёта
коллизий. С технической точки зрения наборы могут быть совершенно разными. Естественно, на практике
используется один исходник. Куда пойдёт каждый треугольник создаваемой в LE карты, определяется
настройками compiler shader'а. Установлен флажок collision -- в cform, установлен rendering -- в
visuals. Установлены оба -- мы сможем и увидеть объект, и споткнуться об него. Пример collision-only
объекта -- невидимые стенки (fake) вокруг карты. Видимого, но неосязаемого -- маскировочная сетка.
Понятно, что взаимодействие с cform-геометрией не ограничивается возможностью упереться в неё. Игрок
может подхватить лучевую болезнь (materials\death вроде) или зашуршать листвой (materials\bush и другие).
Так вот, последнее и есть фуфло. С лодами, а точнее -- с "фанерными" задниками, как я уже объяснял,
оно не связано никак. А, есть два исключения, когда назначение геометрии определяется по game material:
лестницы (идут в level.spawn/all.spawn) и разбиваемая геометрия (туда же, плюс внешний .ogf).


[Вопрос]

Что такое MU-модели? Уровни детализации в X-Ray.

[Ответ]

MU-модели (в игре) -- это статические объекты карты с регулируемым вплоть до "фанерных" задников
уровнем детализации. Хранятся в level.geom в виде однократно заданной эталонной геометрии и набора мест
расположения (матрица + координаты каркаса для задника). Такая схема экономит память и обеспечивает
выполнение требования D_TREE-шейдеров касательно начала координат. Смысл прозрачный: деревья/кусты
должны колебаться от ветра, да не как попало, а от земли. Вот поэтому исходные модели (.object-ы)
крупной растительности всегда растут из начала координат.
По поводу уровня детализации. X-Ray использует алгоритм плавного изменения детализации геометрии
(конкретно -- sliding window progressive meshes). То есть на этапе компиляции для MU-моделей рассчитываются
(подробнее ищите по qslim) и сохраняются (в компактном виде) все упрощённые модели. Во время рисования
выбирается наиболее подходящий вариант либо вовсе фанерный задник (то есть level_lods.dds). Это всё
касается современных сборок. В каких-нибудь 1114/1154 MU-моделей нет вообще, а в 1935 были только задники.
Для скелетных моделей (OGF) плавная детализация также возможна и широко используется. Только без
billboard'ов, разумеется.


[Вопрос]

Из чего состоит .object и как он связан с секторами?

[Ответ]

Файл .object состоит из mesh'ей. В терминах майки mesh -- это shape. При экспорте из майки каждому shape
будет соответствовать mesh. Термин shape в сталкере (как в игре, так и SDK) используется ещё в скелетных
моделях и в spawn-объектах типа space_restrictor и т.п., но секторов/порталов это не касается. То есть,
sector#0000Shape -- это просто имя mesh'а, автоматически заданное декомпилятором. Означает, что данный
mesh является первой (0000) частью сектора с именем "sector". Гипотетический mesh с именем sector_0008#0007Shape
будет означать, что он является седьмым (0007) кусочком сектора с именем "sector_0008". Имена mesh'ей
не имеют значения. Это всего лишь алгоритм наименования в декомпиляторе. 


[Вопрос]

Как работают сектора и порталы в Сталкере и для чего они?

[Ответ]

Сектора/порталы и HOM нужны только для улучшения производительности. Принцип работы с/п, думаю, понятен:
сцена делится на некоторое количество объёмов (секторов), задаются окна (порталы), через которые (и только
через которые) наблюдатель может увидеть внутренности других секторов. Красные области -- порталы,
геометрия разных секторов окрашивается по-разному, но смотрите настройки LE. Разбивка делается в LE 
(полу)автоматически при условии правильно подготовленной геометрии. Что это значит, можно понять по любой
декомпилированной с "-mode raw" карте (выбирайте небольшие вроде mp_bath).
Ещё вариант: mp_atp из ТЧ SDK. Достаточно заменить файлы sector.part и portal.part на их backup-копии
(sector.~part и portal.~part соответственно).
HOM -- независимый от с/п механизм. Опять же, примером может служить почти любая декомпилированная карта,
лишь старайтесь минимизировать количество треугольников в HOM-объекте, одновременно максимизируя закрываемую
ими площадь. Например, нет никакой необходимости точно повторять срез холма, достаточно очень грубого
приближения (см. мусорные кучи на свалке). Для ландшафта HOM вряд ли можно сделать отличным от ручного
способом, а для зданий имеет смысл попробовать встроенный в майку огрубитель геометрии. Как убедиться,
что HOM полезен на данной карте? Скажем, записав демку облёта карты и прогоняя её с level.hom и без.


[Вопрос]

Необходимо ли подготавливать отдельную геометрию?

[Ответ]

Нет. Важна только форма организации геометрии. Если две соединённые дверным проходом комнаты должны быть
в разных секторах, то нужно:
1) поместить их в разные mesh'и (в майке -- в разных shape'ах);
2) обеспечить простую геометрию стыка (портал -- 3,4,5,6-угольник). Впрочем, LE вроде может съесть и
довольно сложные стыки, но утверждать это не буду.
Что касается комнаты в mp_bath, то сейчас трудно сказать точно, почему она не является отдельным сектором.
LE создаёт секторы основываясь на геометрии, тогда как декомпилятор, наоборот, экспортирует .object'ы,
основываясь на информации о секторах.


[Вопрос]

Что насчет использывания xrLC ЧН для сборки карт ТЧ?

[Ответ]

xrLC ЧН можно использовать для сборки карт ТЧ:
1) аккуратно адаптировать gamedata ТЧ так, чтобы его принимал LE ЧН (погода там и прочие мелочи);
2) сделать hardlink'и для .thm из $textures$ в $game_textures$ (или тупо скопировать);
3) загрузить карту в LE ЧН, приготовить для сборки, потом xrLC ЧН и xrDO_Light ЧН;
4) загрузить карту в LE ТЧ, собрать оставшуюся требуху (тесты проводились без добавления ИИ, конечно).


[Вопрос]

А почему бы не создать чистильщик invalid faces для декомпилированных карт?

[Ответ]

Давайте подумаем. Дано: 
1) скомпилированная карта из современной сборки (2215 и старше);
2) известный факт, что при компиляции xrLC ругается на неправильные треугольники. 
Формальный вывод? Правильно, уже скомпилированная карта ошибок не содержит.
Реально ситуация более сложная: могут быть полностью вырожденные треугольники (то есть площадь их
строго равна 0) из-за nvstrip/nvmeshmender, но такие можно безболезненно удалять автоматически, что
и делается. Откуда же берутся битые полигоны при повторной компиляции? Вот откуда: xrLC пытается
оптимизировать геометрию и объединяет близко расположенные вершины, в результате из "хорошего"
треугольника получается "плохой". Далее, почему вообще нельзя тупо удалять "плохие" треугольники
автоматически, а нужно напрягать этим дизайнера? Проще всего объяснить на примере escape из 1114/1154.
Декомпилируйте, загрузите его в LE, импортируйте список ошибок из logs\\converter_escape1154.err и
представьте, что все подсвеченные полигоны были удалены.


[Вопрос]

Экспортировал геометрию Сталкера, выдранную плагином kasper'а, в SDK, тормозит, почему?

[Ответ]

Скорость работы и загрузки LE зависит от того, как побита геометрия. Можно выписать такие правила:
1) чем больше mesh'ей в .object'ах, тем медленнее работа;
2) чем больше треугольников в отдельной mesh'и и чем сложнее её форма, тем медленнее загрузка карты в LE;
3) количество _отдельных_ .object на скорость работы и загрузки влияет слабо.
Ключ "-mode maya" изначально был сделан для загрузки геометрии в майку. При этом создаётся один .object,
но куча mesh'ей, что удобно для работы в майе (позднее пригодилось и для макс-плагина). Однако перед
экспортом нужно все эти кучи mesh'ей объединять в логические группы (здания, земля и т.д.) для быстрой
работы LE.


[Вопрос]

Перенос ТЧ в ЧН, ЧН в ТЧ и тому подобное. Как осуществить?

[Ответ]

По поводу переноса ТЧ в ЧН (целиком). Вот инструкция для 3120.
1) Поправить XR_3DA.exe из 3120 таким образом (чтоб работал с .dbN от русской версии):

; заменяем SEED0_WW на SEED0_RU
0x000e90d4: 0x4b -> 0x36
0x000e90d5: 0xbc -> 0x94
0x000e90d6: 0x5b -> 0x32
0x000e90d7: 0x00 -> 0x01

; заменяем SEED_WW на SEED_RU
0x000e9154: 0xeb -> 0xd3
0x000e9155: 0xb2 -> 0xa9
0x000e9156: 0x6e -> 0x31
0x000e9157: 0x01 -> 0x01

; заменяем SIZE_MULT_WW на SIZE_MULT_RU
0x0000fedc: 0x04 -> 0x08

2) "aiwrapper -upgrade 3120". На выходе -- дерево с all.spawn и level.ai;
3) Поправить fsgame.ltx (config -> configs и ещё что-то);
4) Поправить погоду, что-то в configs\ui -- по вылетам понятно;
5) Заменить некоторые .ogf/.omf (вороны, люди -- по вылетам будет понятно).
Это минимум для запуска.
Для переноса в финалку ЧН, вместо 1) придётся перепаковать архивы, потом "aiwrapper -upgrade 3456"
и дохера возни со скриптами, конфигурационными файлами и моделями.
Для частичного переноса карт из ТЧ в ЧН, видимо, придётся все их декомпилировать, править ИИ-компоненты, 
склеивать новый game.graph и делать -upgrade. Как сохранить smart_cover's -- х.з. Перенос карт ЧН в
ТЧ -- то же самое, кроме двух последних действий.

[Дополнение 7.09.08]

И еще про полный перенос ТЧ в ЧН (3502, не 3120). all.spawn, который получится после "aiwrapper -upgrade -3502",
нужно будет один раз разобрать командой "acdc_cs.pl -d all.spawn -o aaa -w -l". Потом "-w" не нужна, только "-l".
Это как минимум, в действительности там ещё много чего придётся делать.


[Вопрос]

После переноса ТЧ на двиг 3120 бессмертные NPC. Как исправить?

[Ответ]

См. функцию invlulnerable(). Вписать в xr_logic.script по аналогии. Как раз после этого нужно будет
заменить .omf для людей во избежание вылета. Ну и гранаты в xml-профили NPC добавьте.

Написал bardak, собрал loxotron.